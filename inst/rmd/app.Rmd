---
output: html_document
runtime: shiny #shiny_prerendered
title: Shinyscreen
author: Environmental Cheminformatics Group, LCSB, University of Luxembourg
---


```{r, include = "false"}
SHINYSCREEN_PATH <- "~/cabinet/shinyscreen"
FN_WORKDIR_STATE <- "conf-state.yaml"
load_package <- function(name,src=NULL,reload_pkgs=NULL) {

    for (name in c(reload_pkgs,name)) {
        pname <- paste0("package:",name)
        if (pname %in% search()) eval(substitute(detach(pname,unload=T),list(pname=pname)))
    }
    if (!is.null(src)) devtools::install(src, upgrade = "never")

    for (name in rev(c(reload_pkgs,name))) {
        eval(substitute(library(name,list(name=name))))
    }
    invisible(NULL)
}

proj <- getwd()
setwd(proj)


dir.create("pkgs",showWarnings = F)
.libPaths(c("pkgs",.libPaths()))
Sys.setenv("R_LIBS_USER"="pkgs")
```

```{r, include="false"}
load_package("shinyscreen",src="~/cabinet/shinyscreen")
## library(shinyscreen)
deps_path <- getwd() #Where includes are stored.
fn_rmd_conf <- file.path(deps_path,'conf.Rmd')
```



<!-- ```{r, file=fn_rmd_conf, echo=F} -->

                
<!-- ``` -->

```{r, context='setup', echo=F}
def_state <- new_state()
```

# Configuration {.tabset}

## Inputs


<details>
<summary>Specify the project directory</summary>
This is where the output files and the state of the analysis will be
saved.
</details>
```{r, echo=FALSE}
actionButton(inputId = "project_b",
             label= "Project")

```


Load the config file if needed.

```{r, echo=FALSE}
actionButton(inputId = "conf_file_b",
             label= "Load config")

```

<details><summary>Load the compound list(s)</summary>
A compound list is composed of entries describing compounds. This
description is used to search for its spectrum in the data file. The
list is a table in the ***CSV*** format and contains these columns,

* ***ID*** : required column, must be filled; this is a user-defined
  ID, uniquely associated with a compound
  
* ***Name*** : this column can be left blank; if not, it should contain the
  names of the compounds
  
* ***SMILES*** : a _SMILES_ string, describing the structure of the
  compound; this entry can be left empty only if one of either
  ***Formula***, or ***mz*** entries are not
  
* ***Formula*** : a chemical formula of a compound; this field can be
  empty only if one of either ***SMILES***, or ***mz*** entries are
  not
  
* ***mz*** : mass of the ionised compound; this field can be left
  empty only if one of either ***SMILES***, or ***Formula*** is not
  
* ***CAS*** : the CAS number of the compound; it can be left empty

* ***RT*** : retention time of the MS1 peak in minutes, if known; can
  be left empty.
  
Only ***ID*** and one of ***SMILES***, ***Formula*** or ***mz*** must
be filled. When structure, or a formula of a compound is known, it is
also possible to look for various adducts in the sample. Of course,
scanning for completely unknown compounds is also supported by the
***mz*** column. In this case, ***mz*** is the mass of the ion.

It is strongly recommended to quote SMILES, names and formulas in the
CSV file used with Shinyscreen.
</details>
```{r, echo=FALSE}
actionButton(inputId = "comp_list_b",
             label= "Compound list(s)")

```

<details><summary>Load compound set list (_setid_ table)</summary>
The compound lists can contain more entries than is necessary. Using
the _setid_ lists, it is possible to create _compound sets_ which
contain only those compounds that will actually be searched for in the
data files. A _setid table_ is a _CSV_ containing at least two
columns,

* ***ID*** : the ID entry from the compound list

* ***set*** : an user-defined set name.
</details>
```{r, echo=FALSE}
actionButton(inputId = "setid_b",
             label= "Load the setid table")

```

<details><summary>Load data files</summary>
Shinyscreen currently supports only the ***mzML*** file format. After
loading the files, set file tags in the file table (column
***tag***). Additionally, specify a set of compounds that is supposed
to be extracted from the file using the ***set*** column. Finally,
specify the ***adduct*** in the adduct column. In case of compounds
with unknown structure and formula, the adduct is ignored for obvious
reasons.
</details>
```{r, echo=FALSE}
actionButton(inputId = "datafiles_b",
             label= "Load data files.")

```

```{r, context='server', echo=FALSE}
## b_project <- eventReactive(input$project, {
##     #dir <- tk_choose.dir(,caption = "Select project directory")
##     ""
## })
#rv_conf$project
#print(rv_conf)
## rv_conf$project <- b_project()
```

## Extraction

### Spectra extraction based settings

<details><summary>MS1 coarse error</summary> 

Extract all entries matching the target mass within this error in the
precursor table.
</details>
```{r, echo=F}
shinyscreen::mz_input(input_mz = "ms1_coarse",
                      input_unit = "ms1_coarse_unit",
                      def_mz = def_state$conf$tolerance[["ms1 coarse"]],
                      def_unit = "Da")
```

<details><summary>MS1 fine error</summary> 

The precursor table masses can be of lower accuracy. Once there is a
match within the coarse error, it can be further checked versus the
fine error bounds directly in the mass spectrum.

</details>
```{r, echo=F}
shinyscreen::mz_input(input_mz = "ms1_fine",
                      input_unit = "ms1_fine_unit",
                      def_mz = def_state$conf$tolerance[["ms1 fine"]],
                      def_unit = "ppm")
```

<details><summary>MS1 EIC window</summary> 

The mz interval over which the intensities are aggregated to generate
a chromatogram.

</details>
```{r, echo=F}
shinyscreen::mz_input(input_mz = "ms1_eic",
                      input_unit = "ms1_eic_unit",
                      def_mz = def_state$conf$tolerance[["eic"]],
                      def_unit = "Da")
```


<details><summary>Retention time window</summary> 

If the expected retention time has been specified for the compound,
then search for the MS1 signature inside the window defined by this
range.

</details>
```{r, echo=F}
shinyscreen::rt_input(input_rt = "ms1_rt_win",
                      input_unit = "ms1_rt_win_unit",
                      def_rt = def_state$conf$tolerance[["rt"]],
                      def_unit = "min")
```

## Prescreening

<details><summary>MS1 intensity threshold</summary> 

Ignore MS1 signal below the threshold.

</details>
```{r, echo=F}

numericInput(inputId = "ms1_int_thresh",
             label = NULL,
             value = def_state$conf$prescreen$ms1_int_thresh)
```

<details><summary>MS2 intensity threshold</summary> 

Ignore MS2 signal below the threshold.

</details>
```{r, echo=F}

numericInput(inputId = "ms2_int_thresh",
             label = NULL,
             value = def_state$conf$prescreen$ms2_int_thresh)
```


MS1 signal-to-noise ratio.

```{r, echo=F}

numericInput(inputId = "s2n",
             label = NULL,
             value = def_state$conf$prescreen$s2n)
```


<details><summary>MS1/MS2 retention delay.</summary> 

Look for associated MS2 spectrum within this window around the MS1
peak.

</details>
```{r, echo=F}
shinyscreen::rt_input(input_rt = "ret_time_shift_tol",
                      input_unit = "ret_time_shift_tol_unit",
                      def_rt = def_state$conf$tolerance[["ret_time_shift_tol"]],
                      def_unit = "min")
```

## Subsetting and filtering

## Plots

## Report

# Extract Data and Prescreen
<details><summary>Extract spectra from data files.</summary>

After Shinyscreen is configured, the compound and setid lists loaded, it
is possible to proceed with extracting the data. This is potentially a
time-intensive step, so some patience might be needed.

Once the data is extracted, it will be possible to quality check the
spectra associated with the compounds specified in the _setid_ list,
to subset that data, look at the plots and publish a report.

</details>
```{r, echo=FALSE}
actionButton(inputId = "extract",
             label = "Extract")
```


# Browse Results
