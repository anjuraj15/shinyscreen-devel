---
output:
  html_document:
    css: "www/custom.css"
runtime: shiny_prerendered
author: Environmental Cheminformatics Group, LCSB, University of Luxembourg
title: "`r paste('Shinyscreen', packageVersion('shinyscreen'))`"
---

```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri(system.file(package="shinyscreen","www/shinyscreen2.png")), 
               alt = 'logo', 
               style = 'position:absolute; top:0; right:0; padding:5px;')
```


```{r, context='setup', include='false'}
library(data.table)
library(shinyscreen)
library(ggplot2)
### library(shinydashboard)

init <- readRDS("init.rds")
def_state <- new_state()
def_datafiles <- shinyscreen:::dtable(file=character(0),
                                      tag=character(0))
def_datatab <- shinyscreen:::dtable("tag"=factor(),
                                    "adduct"=factor(levels=shinyscreen:::DISP_ADDUCTS),
                                    "set"=factor())

def_summ_subset <- shinyscreen:::dtable("QA Column"=shinyscreen:::QA_FLAGS,
                                        "Select"=factor("ignore",levels=shinyscreen:::SUBSET_VALS))
### RMassBank masks shiny::validate. Unmask it.
validate <- shiny::validate
### def_state$input$tab$tags <- def_datatab
rv_state <- list2rev(def_state)
compl_sets <- eventReactive(rv_state$input$tab$setid,
                            rv_state$input$tab$setid[,unique(set)])
### Reactive values to support some of the UI elements.
### rv_ui <- reactiveValues(datatab=def_tags)

### Update with data-files.
rv_dfile <- reactiveVal(def_datafiles)

### Data-file table when loading.
rv_datatab <- reactiveVal(def_datatab)

### Re-definitions.
PLOT_FEATURES <- shinyscreen:::PLOT_FEATURES

### Plotting parameters.

### Transient rt range.
rv_rtrange <- reactiveValues(min=def_state$conf$rt_min,
                             max=def_state$conf$rt_max)

### Transient mz range.
rv_mzrange <- reactiveValues(min=NA,
                             max=NA)

projects <- list.dirs(path=init$projects, full.names = F, recursive = F)
inputdirs <- list.dirs(path=init$top_data_dir, full.names = F, recursive = F)

```
<style type="text/css">
.main-container {
  max-width: 100%;
  margin-left: auto;
  margin-right: auto;
}
</style>

# {.tabset .tabset-pills}

## Project {.tabset}

<details>
<summary>Projects, input directories and compound lists</summary>

When you start the program with `app` function, you define two
superdirectories: `projects` and `top_data_dir`. Directory `projects` contains
all the existing projects and any new projects defined during the
current session will be saved here. Data inside a project directory
consists of intermediate files, saved states and workflow outputs.

To create a new project, type in the name and press the `Create`
button. To load a project, select the project and press `Load`.

There is also a possibility to save the current project state. Just
use the `Save project` button. This action will record all your
settings and selected inputs.

Each `Shinyscreen` project needs input data: mass spectrometry files
(in mzML format), compound and set lists. These should all be present
before starting `Shinyscreen` in one of the directories under
`projects`.



</details>

### Project management

#### Load or initialise a project

<details>
<summary>Load, or initialise a project</summary>

All projects are shown in the `Avaliable projects`
list. Load the project by pressing `Select project` button. 

If the project is new, it has to contain the compound list(s) and the
set list.

</details>

```{r, echo=F}
selectInput('proj_list',
            label = "Select project",
            choices = projects)
actionButton(inputId = "load_proj_b",
             label= "Load/Initialise")
textOutput("curr_proj")

```


#### Save project
```{r, echo=F}
actionButton(inputId = "save_proj_b",
             label= "Save project")
```

#### Download project

<details> 
<summary>Download results</summary>

Button `Download project` only makes sense to be used if Shinyscreen is
served over network. If this is the case, clicking this button will
download plots and csvs generated in the project directory.
</details>

```{r, echo=F}
downloadButtonRmd <- function (outputId, label = "Download", class = NULL, ...)  {
     tags$a(id = outputId, class = paste("btn btn-default shiny-download-link", 
        class), href = "", target = "_blank", download = NA, 
        icon("download"), label, ...)
 }

downloadButtonRmd("dwn_proj_b",
                  "Download project directory")
```


#### Select data directory
<details>
<summary>More on data directories</summary>

Data directory is a subdirectory of the `top_data_dir` directory which is
one of the arguments to `app` function used to start Shinyscreen
GUI. It contains the `mzML` data files.

Select one of the data directories from the list by clicking the
`Select` button.

</details>

```{r, echo=F}
selectInput('top_data_dir_list',
            label = "Input directories",
            choices = inputdirs)
actionButton(inputId = "sel_data_dir_b",
             label= "Select")
textOutput("curr_data_dir")
```

### Compound list inputs

#### Select compound lists

<details><summary>About compound lists</summary>
A compound list is composed of entries describing compounds. This
description is used to search for its spectrum in the data file. The
list is a table in the ***CSV*** format and contains these columns,

* ***ID*** : required column, must be filled; this is a user-defined
  ID, uniquely associated with a compound
  
* ***Name*** : this column can be left blank; if not, it should contain the
  names of the compounds
  
* ***SMILES*** : a _SMILES_ string, describing the structure of the
  compound; this entry can be left empty only if one of either
  ***Formula***, or ***mz*** entries are not
  
* ***Formula*** : a chemical formula of a compound; this field can be
  empty only if one of either ***SMILES***, or ***mz*** entries are
  not
  
* ***mz*** : mass of the ionised compound; this field can be left
  empty only if one of either ***SMILES***, or ***Formula*** is not
  
* ***CAS*** : the CAS number of the compound; it can be left empty

* ***RT*** : retention time of the MS1 peak in minutes, if known; can
  be left empty.
  
Only ***ID*** and one of ***SMILES***, ***Formula*** or ***mz*** must
be filled. When structure, or a formula of a compound is known, it is
also possible to look for various adducts in the sample. Of course,
scanning for completely unknown compounds is also supported by the
***mz*** column. In this case, ***mz*** is the mass of the ion.

It is strongly recommended to quote SMILES, names and formulas in the
CSV file used with Shinyscreen.

Select one, or more compound lists by clicking `Select` button.
</details>

<div style= "display: flex; vertical-align:top; padding-right: 1.0em"> <!-- comp-list-box -->

<div> <!-- comp-list-sel -->
```{r, echo=FALSE}
selectInput('comp_list',
            label = "Select compound lists",
            multiple = T,
            choices = "")
actionButton(inputId = "comp_list_b",
             label= "Select")

```
</div> <!-- comp-list-sel -->

<div> <!-- comp-list-disp -->

**Selected compound lists**

```{r, echo=FALSE}
htmlOutput('comp_list_report')
```

</div> <!-- comp-list-disp -->

</div> <!-- comp-list-box -->

#### Select set lists

<details><summary>About set lists (_setid_ tables)</summary>
The compound lists can contain more entries than is necessary. Using
the _setid_ lists, it is possible to create _compound sets_ which
contain only those compounds that will actually be searched for in the
data files. A _setid table_ is a _CSV_ containing at least two
columns,

* ***ID*** : the ID entry from the compound list

* ***set*** : an user-defined set name.

Select one set list by clicking `Select` button.
</details>

<div style= "display: flex; vertical-align:top; padding-right: 1em"> <!-- set-list-box -->

<div> <!-- set-list-sel -->

```{r, echo=FALSE}
selectInput('set_list',
            label = "Select set lists",
            multiple = T,
            choices = "")
actionButton(inputId = "set_list_b",
             label= "Select")

```

</div> <!-- set-list-sel -->

<div> <!-- set-list-rep -->

**Selected `setid' list**

```{r, echo=FALSE}
htmlOutput('sets_report')
```

</div> <!-- set-list-rep -->

</div> <!-- set-list-box -->

### Data files
<details><summary>Load data files</summary>
Shinyscreen currently supports only the **mzML** file format. After
loading the files, set file tags in the file table (column
**tag**). Additionally, specify a set of compounds that is supposed
to be extracted from the file using the **set** column. Finally,
specify the **adduct** in the adduct column. In case of compounds
with unknown structure and formula, the adduct is ignored for obvious
reasons.

Select datafiles of interest from the list and confirm the selection
by clicking `Select`.

</details>
```{r, echo=FALSE}

selectInput('dfile_list',
            label = "Select datafiles",
            multiple = T,
            choices = "")
actionButton(inputId = "datafiles_b",
             label= "Load data files.", width="10%")

```

<details><summary>Assign tags to data files.</summary> 

Each tag designates an unique file. Use the table below to assign
tags.

</details>

```{r, echo=FALSE}
DT::DTOutput("datafiles",width="25%")
actionButton("rem_dfiles_b",label="Remove selected entries",width="10%")
```

<details>

<summary>Assign sets to tags.</summary>

For each tag, assign a set and an adduct (if the structure information
exists, otherwise _adduct_ column is ignored).

</details>

```{r, echo=F}
DT::DTOutput("datatab",width="25%")
```

## Configure, Extract, Prescreen {.tabset}

<div class = "flex-cols"> <!-- confstatus-panes -->
<!-- confstatus-panes-left -->
<div>					
```{r, child='app_config_and_status.Rmd'}
```
</div> <!-- confstatus-panes-left -->
<div>  <!-- confstatus-panes-right -->

#### Control

<div style="display: flex;flex-flow: row wrap;">
```{r, echo=FALSE}
actionButton(inputId = "extract_b",
             label = "Extract")
```

```{r, echo=FALSE}
actionButton(inputId = "presc_b",
             label = "Prescreen")
```
</div>

#### Overview

- Has the data been extracted? `r htmlOutput("is_extracted_stat", inline=T)`
- Has the data been auto-quality checked? `r htmlOutput("is_qa_stat", inline=T)`

##### Extraction

- MS1 coarse: `r htmlOutput("ms1_coarse_stat", inline=T)`
- MS1 fine: `r htmlOutput("ms1_fine_stat", inline=T)`
- MS1 eic: `r htmlOutput("ms1_eic_stat", inline=T)`
- Retention time window: `r htmlOutput("rt_stat", inline=T)`

##### Prescreening

- Intensity Threshold (MS1): `r htmlOutput("ms1_int_thresh_stat", inline=T)`
- Intensity Threshold (MS2): `r htmlOutput("ms2_int_thresh_stat", inline=T)`
- Retention time shift: `r htmlOutput("ret_time_shift_tol_stat", inline=T)`
- Signal-to-noise ratio: `r htmlOutput("s2n_stat", inline=T)`



</div> <!-- confstatus-panes-right -->
</div> <!-- confstatus-panes -->


<!-- TODO: This should be readded at some point. -->
<!-- ```{r, child='app_compound_lists_and_sets.Rmd'} -->
<!-- ``` -->


## Results Explorer

<details>
<summary>Learn more about compound index</summary>

Compound index is used to select entries from the input compound/mass
lists. What exactly is going to be shown depends on what was chosen
using the *Group* control. The *Group* control allows user to choose
which features of data should be used to group entries together. For
example, if there are multiple input data files, then grouping by
*tag* will result in a single compound index entry for all the ions of
the same adduct type, the same ID across the different data files. If
a user additionally selects *adduct*, then a single entry represents
masses belonging to the same compound ID, even if they are of
differing adduct types.

**IMPORTANTLY**, the metadata such as *mz*, or retention time are
**averages** over the group of of results belonging to the same
compound index entry. If the exact mass of a singe entry is needed,
consult the summary table. Alternatively, remove grouping and you 
shall get non-averaged values.

The second group of controls influence the precedence of parent
features when determining the order of items in the compound index.

There two derived quantities, *qlt_ms1* and *qlt_ms2*. The only
purpose they serve is to help sorting the data. The highest score in
any of the two categories is ten. If an index entry scores ten, this
means that at least one in the collection of results represented by
the index has passed all the quality checks.

When an entry of the index is selected, the plots of its EICs and MS2
spectra (if any) are shown in the plotting section. Each result in the
index entry collection is represented by a single line. 

For example, let there be six data files, the three of them scanned
for [M+H]+ and the other three for [M-H]- ions. If the index is
grouped by only by *tag*, there exists a compound with the ID 42, then
the compound index is going to contain two entries for compound 42,
one labelled by [M+H]+ in the adduct column and another labelled with
[M-H]-. If one of those entries is selected, a single EIC, or mz plot
is going to contain three lines, each representing a single *tag*. If,
additionally, the results are grouped by *adduct*, the index is going
to contain only a single entry for the ID 42. The plot, in this case,
contains six lines (for each existing combination of tag and adduct).

</details>
<div class='flex-layers'> 
```{r, child='app_results_explorer_cindex.Rmd'}
```
<details>
<summary>Operations over compound index.</summary>

- **Report** is currently a collection of all plots of items in the compound index.
- **Summary table** comprises of all the metadata related to parent ions and the selected MS2 spectra (if present).
- **Table of MS2 spectra** contains information on all the MS2 spectra and their parents.
- **MetFrag summary table** contains a summary of the MetFrag results for all compound index entries.

</details>
```{r, child='app_results_explorer_cindex_controls.Rmd'}
```
</div>


<!-- ENGINE -->

```{r, echo = F, context = 'setup'}
shinyscreen_server <- shinyscreen:::mk_shinyscreen_server(projects=projects,
                                                          init=init)
```

```{r, echo = F, context = 'server'}
shinyscreen_server(input=input,output=output,session=session)
```

